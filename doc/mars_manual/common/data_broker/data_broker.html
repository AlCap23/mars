<!-- DO NOT EDIT THIS FILE! IT IS AUTOMATICALLY GENERATED BY rst2marshtml //-->
<!DOCTYPE html>
<html>
  <head>
    <title>MARS Simulator</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <meta name="description" content="MARS is a flexible physics simulator.">
    <meta name="author" content="MARS Project">
    <meta name="keywords" content="MARS, simulation, physics, robotics">
    <link rel="stylesheet" type="text/css" href="../../../../src/css/mars_default.css" media="all" />
  </head>
<body>
  <div class="nav-box">
    <h2>Navigation</h2>
    <nav>
      <ol>
        <li><a href="../../../../mars_manual/index.html">Home</a></li>
      </ol>
    </nav>
  </div>
  <div id="content">
  <header>
    <a href="../../../../mars_manual/index.html"><img src="../../../../src/images/logo_v2_wob.png" alt="MARS" /></a>
  </header>
<div class="document" id="data-broker-data-broker">
<h1 class="title">Data Broker {#data_broker}</h1>
<div class="section" id="overview">
<h1>Overview</h1>
<p>The data_broker library provides functionality to manage data transfer
between the components of the MARS simulation. Its interface is defined
in the class
<a class="reference external" href="&#64;ref%20mars::data_broker::DataBrokerInterface">DataBrokerInterface</a>,
while the <a class="reference external" href="&#64;ref%20mars::data_broker::DataBroker">DataBroker</a> class is
the actual implementation.</p>
</div>
<div class="section" id="producers-and-receivers">
<h1>Producers and receivers</h1>
<p>An instance of DataBroker passes data between registered producers and
receivers (see
<a class="reference external" href="&#64;ref%20data_broker::ProducerInterface">ProducerInterface</a> and
<a class="reference external" href="&#64;ref%20mars::data_broker::ReceiverInterface">ReceiverInterface</a>,
respectively) in the MARS framework. For this purpose it holds buffered
local copies of the data packages and is thus able to coordinate data
transfer between various threads.</p>
<p>Consequently, there are a number of ways in which data can be handled.
and for this purpose holds a local copy of the data. For this purpose,
the <a class="reference external" href="&#64;ref%20mars::data_broker::DataBroker">DataBroker</a> calls the
functions produceData and receiveData of the classes implementing the
respective interfaces. When this happens is determined by the way the
producer/receiver is registered with the
<a class="reference external" href="&#64;ref%20mars::data_broker::DataBroker">DataBroker</a>. While producers
can only be registered as timed producers (using a previously created
timer, either manually defined - see
<a class="reference external" href="&#64;ref%20mars::data_broker::DataBroker::createTimer">createTimer</a> - or
using the DataBroker's real time Timer which is automatically created if
a producer is registered with a &quot;<em>realTime</em>&quot; timer), receivers can be
registered in four different ways:</p>
<ol class="arabic simple">
<li>timed</li>
<li>triggered</li>
<li>asynchronous</li>
<li>synchronous</li>
</ol>
<div class="section" id="timed-receivers">
<h2>Timed receivers</h2>
<p>A timed receiver's receiveData function is called by the stepTimer
function of the timer (managed by the DataBroker) with which it was
registered. To create a timed receiver one has to do the following:</p>
<ul class="simple">
<li>call createTimer() with a suitable name</li>
<li>call registerTimedReceiver() with a desired update period</li>
<li>call stepTimer() to step the timer and get the updates</li>
</ul>
<p>The first step can be omitted if an appropriate timer already exists.</p>
<p>NOTE: You will get the latest datum, regardless of whether it has been
updated or not since the last timer step.</p>
</div>
<div class="section" id="triggered-receivers">
<h2>Triggered receivers</h2>
<p>Tp create a triggered receiver, which is receiving data as a result of a
called trigger, the following steps are necessary:</p>
<ul class="simple">
<li>call createTrigger() with a suitable triggerName</li>
<li>call registerTriggered() to register to a certain trigger</li>
<li>call trigger() to manually trigger a certain trigger and update all
receivers registered to it</li>
</ul>
<p>As with timed receivers, one only has to create a new trigger if no
appropriate trigger exists already.</p>
<p>NOTE: You will get the latest datum, regardless of whether it has been
updated or not since the last trigge call.</p>
</div>
<div class="section" id="asynchronous-receivers">
<h2>Asynchronous receivers</h2>
<p>Asynchronous receivers are updated asynchronously whenever the run()
method of the DataBroker is called (which is typically by the MARS
simulation), i.e. are not synchronized with the producers which provide
the data they receive. This means that if the producer updates with a
higher frequency than the receiver, only the last datum is received.</p>
<p>This can be the case if the producer it called from a timer with a
higher frequency than whichever thread processes the data of the
AsyncReceiver. It can also be the case if data are pushed to the
DataBroker via pushData() with a higher frequency.</p>
<ul class="simple">
<li>call registerAsyncReceiver() with (sensor group and name)</li>
</ul>
</div>
<div class="section" id="synchronous-receivers">
<h2>Synchronous receivers</h2>
<p>Synchronous receivers are updated synchronously to the thread which
calls pushData. This should only be used if it is important that no
datum is missed, as it might otherwise slow down whichever process
pushes the data.</p>
<p>&#64;Q: not clear in this context if synchronous receivers will receive data
if there is noone pushing the data</p>
<ul class="simple">
<li>call registerSyncReceiver() with (sensor group and name)</li>
</ul>
</div>
<div class="section" id="typical-use-cases">
<h2>Typical use cases</h2>
<ol class="arabic simple">
<li>Plotter: should run in Asynchronous or Timed mode</li>
<li>File Logger: should run in Asynchronous or Timed mode</li>
<li>Controller: should probably run in Asynchronous mode.</li>
<li>Command: When listening for commands you should run in Synchronous
mode.</li>
</ol>
</div>
</div>
<div class="section" id="data-formats">
<h1>Data formats</h1>
<p>Data is managed by the DataBroker library in the form of a
<a class="reference external" href="&#64;ref%20mars::data_broker::DataPackage">DataPackage</a> which itself
contains a number of instances of
<a class="reference external" href="&#64;ref%20mars::data_broker::DataItem">DataItem</a>. The latter is a
wrapper class for variables of any of the following types:</p>
<ul class="simple">
<li>int</li>
<li>long</li>
<li>float</li>
<li>double</li>
<li>string</li>
<li>bool</li>
</ul>
<p>contained in a std::vector named package. The field name contains a
string describing the <a class="reference external" href="&#64;ref%20mars::data_broker::DataItem">DataItem</a>.</p>
<p>The class <a class="reference external" href="&#64;ref%20mars::data_broker::DataPackage">DataPackage</a> is a
container for multiple instances of
<a class="reference external" href="&#64;ref%20mars::data_broker::DataItem">DataItem</a>. These can be added to
a package and afterwards accessed either by name
(<a class="reference external" href="&#64;ref%20mars::data_broker::DataItem::getItemByName">getItemByName</a>)
or by index
(<a class="reference external" href="&#64;ref%20mars::data_broker::DataItem::getItemByIndex">getItemByIndex</a>).
Also, the method
<a class="reference external" href="&#64;ref%20mars::data_broker::DataItem::getType">getType</a> allows to read
the type of a <a class="reference external" href="&#64;ref%20mars::data_broker::DataItem">DataItem</a> either by
index or name as well.</p>
</div>
<div class="section" id="important-functions">
<h1>Important functions</h1>
<p><a class="reference external" href="&#64;ref%20mars::data_broker::DataBroker::pushData">pushData</a></p>
<p>This function allows to easily write data to the DataBroker without the
need of implementing the DataProducerInterface first. As long as the
used names or consistent (or better, the initially received ID is used),
the DataBroker will overwrite the pushed DataPackage. This can be used,
e.g., for testing purposes, or in general when handling asynchronous
receivers. Another useful application is communication between
libraries: A library can push an initial DataPackage and then register
itself as a receiver of that package. If updates are made to the data by
any other library, the first one will be notified.</p>
<p><a class="reference external" href="&#64;ref%20mars::data_broker::DataBroker::stepTimer">stepTimer</a></p>
<p>This function can be called from outside of DataBroker to step any
previously created timer. It is also called from within DataBroker to
step its own &quot;_realtime_&quot; thread which in turn is activated by
<a class="reference external" href="&#64;ref%20mars::data_broker::DataBroker::runRealtime">runRealtime</a>.</p>
<p><a class="reference external" href="&#64;ref%20mars::data_broker::DataBroker::run">run</a></p>
<p>This function handles asynchronous receivers and has to be called from
another thread than the data producers.</p>
<p><a class="reference external" href="&#64;ref%20mars::data_broker::DataBroker::runRealtime">runRealtime</a></p>
<p>This function activates the &quot;_realtime_&quot; timer of a DatBroker, thus
handling synchronous receivers as well as timed receivers and producers
registered with the timer.</p>
<p>[27.09.2013]</p>
</div>
</div>
      <footer>
        <a href="http://validator.w3.org/check?uri=referer" target="_blank">
          <img src="http://www.w3.org/Icons/valid-html401"
               alt="Valid HTML 4.01 Transitional"/>
        </a>
        <a href="http://jigsaw.w3.org/css-validator/check/referer" target="_blank">
          <img src="http://jigsaw.w3.org/css-validator/images/vcss"
               alt="Valid CSS!"/>
        </a>
      </footer>
    </div>
  </body>
</html>
