<!-- DO NOT EDIT THIS FILE! IT IS AUTOMATICALLY GENERATED BY markdown2marshtml //-->
             <!DOCTYPE html>
             <html>
               <head>
                 <title>MARS Simulator</title>
                 <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
                 <meta name="description" content="MARS is a flexible physics simulator.">
                 <meta name="author" content="MARS Project">
                 <meta name="keywords" content="MARS, simulation, physics, robotics">
                 <link rel="stylesheet" type="text/css" href="../../../src/css/mars_default.css" media="all" />
               </head>
             <body>
               <div class="nav-box">
                 <h2>Navigation</h2>
                 <nav>
                   <ol>
                     <li><a href="../../../mars_manual/index.html">Home</a></li>
                     <li>Common</li>
<ul>
  <li><a href="../../../mars_manual/common/data_broker/data_broker.html">Data Broker</a></li>
<ul>
  <li><a href=#overview>Overview</a></li>
<li><a href=#producers-and-receivers>Producers And Receivers</a></li>
<ul>
  <li><a href=#timed-receivers>Timed Receivers</a></li>
<li><a href=#triggered-receivers>Triggered Receivers</a></li>
<li><a href=#asynchronous-receivers>Asynchronous Receivers</a></li>
<li><a href=#synchronous-receivers>Synchronous Receivers</a></li>
<li><a href=#typical-use-cases>Typical Use Cases</a></li>
</ul>
<li><a href=#data-formats>Data Formats</a></li>
<li><a href=#important-functions>Important Functions</a></li>
</ul>
    <li><a href="../../../mars_manual/common/lib_manager/lib_manager.html">Lib Manager</a></li>
</ul>
    <li><a href="../../../mars_manual/libraries.html">Libraries</a></li>
<li><a href="../../../mars_manual/inner_workings.html">Inner Workings</a></li>
<li><a href="../../../mars_manual/mars_scenes.html">Mars Scenes</a></li>
<li><a href="../../../mars_manual/documentation_structure.html">Documentation Structure</a></li>
<li><a href="../../../mars_manual/installation.html">Installation</a></li>
<li>Tutorials</li>
<ul>
  <li><a href="../../../mars_manual/tutorials/plugin_tutorial.html">Plugin Tutorial</a></li>
  <li><a href="../../../mars_manual/tutorials/building_mars.html">Building Mars</a></li>
  <li><a href="../../../mars_manual/tutorials/advanced_modeling.html">Advanced Modeling</a></li>
  <li><a href="../../../mars_manual/tutorials/basic_modeling.html">Basic Modeling</a></li>
</ul>

                   </ol>
                 </nav>
               </div>
               <div id="content">
               <header>
                 <a href="../../../mars_manual/index.html"><img src="../../../src/images/logo_v2_wob.png" alt="MARS" /></a>
               </header>
<h1 id="data_broker">Data Broker</h1>
<h2 id="overview">Overview</h2>
<p>The data_broker library provides functionality to manage data transfer between the components of the MARS simulation. Its interface is defined in the class <i>DataBrokerInterface</i>, while the <i>DataBroker</i> class is the actual implementation.</p>
<h2 id="producers-and-receivers">Producers and receivers</h2>
<p>An instance of DataBroker passes data between registered producers and receivers (see <i>ProducerInterface</i> and <i>ReceiverInterface</i>, respectively) in the MARS framework. For this purpose it holds buffered local copies of the data packages and is thus able to coordinate data transfer between various threads.</p>
<p>Consequently, there are a number of ways in which data can be handled. and for this purpose holds a local copy of the data. For this purpose, the <i>DataBroker</i> calls the functions produceData and receiveData of the classes implementing the respective interfaces. When this happens is determined by the way the producer/receiver is registered with the <i>DataBroker</i>. While producers can only be registered as timed producers (using a previously created timer, either manually defined - see <i>createTimer</i> - or using the DataBroker's real time Timer which is automatically created if a producer is registered with a &quot;<em>realTime</em>&quot; timer), receivers can be registered in four different ways:</p>
<ol style="list-style-type: decimal">
<li>timed</li>
<li>triggered</li>
<li>asynchronous</li>
<li>synchronous</li>
</ol>
<h3 id="timed-receivers">Timed receivers</h3>
<p>A timed receiver's receiveData function is called by the stepTimer function of the timer (managed by the DataBroker) with which it was registered. To create a timed receiver one has to do the following:</p>
<ul>
<li>call createTimer() with a suitable name</li>
<li>call registerTimedReceiver() with a desired update period</li>
<li>call stepTimer() to step the timer and get the updates</li>
</ul>
<p>The first step can be omitted if an appropriate timer already exists.</p>
<p>NOTE: You will get the latest datum, regardless of whether it has been updated or not since the last timer step.</p>
<h3 id="triggered-receivers">Triggered receivers</h3>
<p>To create a triggered receiver, which is receiving data as a result of a called trigger, the following steps are necessary:</p>
<ul>
<li>call createTrigger() with a suitable triggerName</li>
<li>call registerTriggered() to register to a certain trigger</li>
<li>call trigger() to manually trigger a certain trigger and update all receivers registered to it</li>
</ul>
<p>As with timed receivers, one only has to create a new trigger if no appropriate trigger exists already.</p>
<p>NOTE: You will get the latest datum, regardless of whether it has been updated or not since the last trigger call.</p>
<h3 id="asynchronous-receivers">Asynchronous receivers</h3>
<p>Asynchronous receivers are updated asynchronously whenever the run() method of the DataBroker is called (which is typically by the MARS simulation), i.e. are not synchronized with the producers which provide the data they receive. This means that if the producer updates with a higher frequency than the receiver, only the last datum is received.</p>
<p>This can be the case if the producer it called from a timer with a higher frequency than whichever thread processes the data of the AsyncReceiver. It can also be the case if data are pushed to the DataBroker via pushData() with a higher frequency.</p>
<ul>
<li>call registerAsyncReceiver() with (sensor group and name)</li>
</ul>
<h3 id="synchronous-receivers">Synchronous receivers</h3>
<p>Synchronous receivers are updated synchronously to the thread which calls pushData. This should only be used if it is important that no datum is missed, as it might otherwise slow down whichever process pushes the data.</p>
<p>@Q: not clear in this context if synchronous receivers will receive data if there is noone pushing the data</p>
<ul>
<li>call registerSyncReceiver() with (sensor group and name)</li>
</ul>
<h3 id="typical-use-cases">Typical use cases</h3>
<ol style="list-style-type: decimal">
<li>Plotter: should run in Asynchronous or Timed mode</li>
<li>File Logger: should run in Asynchronous or Timed mode</li>
<li>Controller: should probably run in Asynchronous mode.</li>
<li>Command: When listening for commands you should run in Synchronous mode.</li>
</ol>
<h2 id="data-formats">Data formats</h2>
<p>Data is managed by the DataBroker library in the form of a <i>DataPackage</i> which itself contains a number of instances of <i>DataItem</i>. The latter is a wrapper class for variables of any of the following types:</p>
<ul>
<li>int</li>
<li>long</li>
<li>float</li>
<li>double</li>
<li>string</li>
<li>bool</li>
</ul>
<p>contained in an td::vector named ackage. The field ame contains a string describing the <i>DataItem</i>.</p>
<p>The class <i>DataPackage</i> is a container for multiple instances of <i>DataItem</i>. These can be added to a package and afterwards accessed either by name (<i>getItemByName</i>) or by index (<i>getItemByIndex</i>). Also, the method <i>getType</i> allows to read the type of a <i>DataItem</i> either by index or name as well.</p>
<h2 id="important-functions">Important functions</h2>
<p><i>pushData</i></p>
<p>This function allows to easily write data to the DataBroker without the need of implementing the DataProducerInterface first. As long as the used names or consistent (or better, the initially received ID is used), the DataBroker will overwrite the pushed DataPackage. This can be used, e.g., for testing purposes, or in general when handling asynchronous receivers. Another useful application is communication between libraries: A library can push an initial DataPackage and then register itself as a receiver of that package. If updates are made to the data by any other library, the first one will be notified.</p>
<p><i>stepTimer</i></p>
<p>This function can be called from outside of DataBroker to step any previously created timer. It is also called from within DataBroker to step its own &quot;_realtime_&quot; thread which in turn is activated by <i>runRealtime</i>.</p>
<p><i>run</i></p>
<p>This function handles asynchronous receivers and has to be called from another thread than the data producers.</p>
<p><i>runRealtime</i></p>
<p>This function activates the &quot;_realtime_&quot; timer of a DatBroker, thus handling synchronous receivers as well as timed receivers and producers registered with the timer.</p>
<p>[27.09.2013]</p>

      <footer>
        <a href="http://validator.w3.org/check?uri=referer" target="_blank">
          <img src="http://www.w3.org/Icons/valid-html401"
               alt="Valid HTML 4.01 Transitional"/>
        </a>
        <a href="http://jigsaw.w3.org/css-validator/check/referer" target="_blank">
          <img src="http://jigsaw.w3.org/css-validator/images/vcss"
               alt="Valid CSS!"/>
        </a>
      </footer>
    </div>
  </body>
</html>
