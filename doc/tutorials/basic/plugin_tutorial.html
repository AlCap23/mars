<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <link rel="stylesheet" type="text/css" href="../../css/mars_default.css" media="all" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.9.1: http://docutils.sourceforge.net/" />
<title>Basic Modeling Tutorial</title>
</head>
<body>
  <div class="nav-box">
    <h3>Navigation</h3>
    <nav>
      <ol>
        <li><a href="../../index.html">Home</a></li>
      </ol>
    </nav>
  </div>

  <div id="content">
    <header>
      <img src="../../images/logo_v2_wob.png" alt="MARS" />
    </header>

<div class="document" id="basic-modeling-tutorial">
<h2 class="title">Basic Plugin Tutorial</h2>
<p style="text-align: center;">
<img src="../../images/robo.jpg" width="400px" alt="robo plugin" />
</p>
<div class="section" id="introduction">
<h3>Introduction</h3>
<p>There are different possibilities how the MARS simulation can be used. One possibility is to write a plugin that handles the loading of a scenario and interfaces the simulation to some control software. Also, in many cases, the control software can be directly wrapped into a simulation plugin. This tutorial will guide you how to create a new plugin, load your scene, and control the simulation.</p>
</div>
<div class="section" id="prerequisites">
<h3>Prerequisites</h3>
<p>We assume you already have a MARS development environment setup in
&quot;$MARS_DEV_ROOT&quot;. You should also have a robot scene file to start with (if not you can use this <a href="robo.scn">scene</a> to follow the tutorial. You should have a terminal opened with the $MARS_DEV_ROOT/env.sh sourced into it.  <code class="lang-bash block">cd $MARS_DEV_ROOT;
. env.sh</code>
</p>
</div>
<div class="section" id="basic-plugin">
<h3>Basic Plugin</h3>
<h4>Create and build a new plugin</h4>
<p>To setup your first plugin you can use a script wich will create a new plugiin:
  <code class="lang-bash block">cd $MARS_DEV_ROOT/mars/plugins/plugin_template
./cnp.sh</code>
The script will ask you for the project name, which will be also the class name of the main c++ class. E.g. we can enter "BasicPlugin" here. Then you can enter a description of your plugin ("The plugin created by following the guide of the basic plugin tutorial."). Afterwards, enter the author name, email, and confirm your data. The script will create your plugin one folder above the script ("$MARS_DEV_ROOT/mars/plugins/BasicPlugin"). You can go into that folder and use the build.sh script to build the plugin for a first test if everything went well. To install the plugin you have to use "make install" within the new created build folder.
  <code class="lang-bash block">cd $MARS_DEV_ROOT/mars/plugins/BasicPlugin
./build.sh
cd build
make install
</code>
Now copy the "mars_default" configuration to "mars_basic_plugin" and add the plugin to the "other_libs.txt" within "mars_basic_plugin" to load the new plugin when starting MARS.
  <code class="lang-bash block">cd $MARS_DEV_ROOT/install/configuration
cp -r mars_default mars_basic_plugin
cd mars_basic_plugin
</code>
other_libs.txt:
  <code class="lang-bash block">/home/malter/Arbeit/LIMES/auto-dev/install/lib/liblog_console.so
/home/malter/Arbeit/LIMES/auto-dev/install/lib/libconnexion_plugin.so
/home/malter/Arbeit/LIMES/auto-dev/install/lib/libdata_broker_gui.so
/home/malter/Arbeit/LIMES/auto-dev/install/lib/libcfg_manager_gui.so
/home/malter/Arbeit/LIMES/auto-dev/install/lib/liblib_manager_gui.so
BasicPlugin
</code>
Start the simulation:
  <code class="lang-bash block">mars_app
</code>
</p>

<h4>Adapt the plugin</h4>
In the "$MARS_DEV_ROOT/mars/plugins/BasicPlugin/src/BasicPlugin.cpp" you will find a "init()" function that is called by the simulation to initialize the plugin. Just comment in the loadScene line with the path to your scene file.
  <code class="lang-bash block">      void BasicPlugin::init() {
        // Load a scene file:
        control->sim->loadScene("robo.scn");
</code>
In this tutorial we are going to access the motors and sensors of the simulation. To do that we first need to include the corresponding interfaces:
  <code class="lang-bash block">#include &lt;mars/interfaces/sim/MotorManagerInterface.h>&gt;
#include &lt;mars/interfaces/sim/SensorManagerInterface.h&gt;
</code>
To control the robot in the simulation you can set motor values in the update callback. The update callback is triggered by the simulation thread giving the simulation step time as parameter. Here we can set some motor values:
  <code class="lang-bash block">      void BasicPlugin::update(sReal time_ms) {

        control->motors->setMotorValue(1, 1.0);
        control->motors->setMotorValue(2, 3.0);
      }
</code>
After doing "make install" in "$MARS_DEV_ROOT/mars/plugins/BasicPlugin/build" we should have a small robot driving a circle when starting the simulation. <br/>
In the next step we want to read the sensor values of the laserscanner to create a wall following behavior. We can acess the sensor values by the id the senor gets when it is loaded into the simulation:
  <code class="lang-bash block">      void BasicPlugin::update(sReal time_ms) {
        static unsigned long laserId = control->sensors->getSensorID("laser");

        control->motors->setMotorValue(1, 1.0);
        control->motors->setMotorValue(2, 3.0);
      }
</code>
The "getSensorData()" methods gets the sensor id and a pointer to a unallocated sReal pointer. It allocates memory for the sensor data and it is important to free the memory after reading the sensor data. The method returns the number of values representing the sensor data.
  <code class="lang-bash block">      void BasicPlugin::update(sReal time_ms) {
        static unsigned long laserId = control->sensors->getSensorID("laser");
        sReal *sensorData;
        int numSensorValues = control->sensors->getSensorData(laserId, &sensorData);
        assert(numSensorValues == 8);
        if(sensorData[3] < 1.0 || sensorData[0] < 0.4) {
          control->motors->setMotorValue(2, 12.0);
        }
        else if(sensorData[0] > 0.7) {
          control->motors->setMotorValue(2, 4.8);
        }
        else {
          control->motors->setMotorValue(2, 5.0);
        }
        control->motors->setMotorValue(1, 5.0);
        free(sensorData);
      }
</code>
Now we can do "make install" again, start the simulation, and we should see robot following the walls! <br/>
The plugin source generated by the "cnp.sh" script includes many commented code, that gives examples how to use the simulation modules like the "DataBroker", the "CFGManager", or the "MainGUI". A seperated documentation of these modules will be created soon.
</div>
    <footer>
      <a href="http://validator.w3.org/check?uri=referer" target="_blank">
        <img src="http://www.w3.org/Icons/valid-html401"
             alt="Valid HTML 4.01 Transitional"/>
      </a>
      <a href="http://jigsaw.w3.org/css-validator/check/referer" target="_blank">
        <img src="http://jigsaw.w3.org/css-validator/images/vcss"
             alt="Valid CSS!"/>
      </a>
    </footer>
</div>
</body>
</html>
